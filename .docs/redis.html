<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2023-11-28T23:26:37.875995"><meta name="build-number" content="${buildNumber}">       <title>Redis | Yui</title><script id="virtual-toc-data" type="application/json">[{"id":"17e0aa8f_166","level":0,"title":"底层","anchor":"#17e0aa8f_166"},{"id":"17e0aa8f_176","level":0,"title":"问答","anchor":"#17e0aa8f_176"},{"id":"17e0aa8f_284","level":0,"title":"命令","anchor":"#17e0aa8f_284"},{"id":"17e0aa8f_305","level":0,"title":"分布式锁","anchor":"#17e0aa8f_305"},{"id":"websites","level":0,"title":"Websites","anchor":"#websites"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Redis | Yui"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Yui Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="redis.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Redis | Yui"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "redis.html#webpage", "url": "redis.html", "name": "Redis | Yui", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Yui Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Redis" data-main-title="Redis" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="framework"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Yui  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Redis"  id="Redis.md"  >Redis</h1>  <section class="chapter"><h2 id="17e0aa8f_166" data-toc="17e0aa8f_166">底层</h2><ol class="list _decimal" id="17e0aa8f_167"  type="1"  ><li class="list__item" id="17e0aa8f_168"><p>使用IO多路复用</p></li><li class="list__item" id="17e0aa8f_169"><p>非CPU密集型任务</p></li><li class="list__item" id="17e0aa8f_170"><p>纯内存操作</p></li><li class="list__item" id="17e0aa8f_171"><p>巧妙数据结构</p></li></ol><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_172"><p id="17e0aa8f_173"><span class="control" id="17e0aa8f_174">非关系型数据，存储在内存中</span></p><p id="17e0aa8f_175">底层是一个大Map，key是字符串，value可能是字符串，哈希，列表等。 C语言实现，结构体redisObject</p></aside></section><section class="chapter"><h2 id="17e0aa8f_176" data-toc="17e0aa8f_176">问答</h2><section class="chapter"><h3 id="17e0aa8f_177" data-toc="17e0aa8f_177">一、单线程原理</h3><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_178"><p id="17e0aa8f_179">Redis单线程指的是网络请求模块使用了一个线程，其他的模块仍是用了多个线程，并不是一味的单线程完成任务。</p><p id="17e0aa8f_180">利用了epoll的多路复用特性，因此可以采用单线程来处理网络请求</p></aside></section><section class="chapter"><h3 id="redis" data-toc="redis">二、Redis数据类型</h3><div class="table-wrapper" ><table class="wide" id="17e0aa8f_181"  ><thead><tr class="ijRowHead" id="17e0aa8f_182"><th id="17e0aa8f_183"><p>类型</p></th><th id="17e0aa8f_184"><p>描述</p></th><th id="17e0aa8f_185"><p>实现原理</p></th></tr></thead><tbody ><tr id="17e0aa8f_186"><td id="17e0aa8f_187"><p>String</p></td><td id="17e0aa8f_188"><p>字符串类型，最简单的类型</p></td><td id="17e0aa8f_189"><p>类似数组的形式存储</p></td></tr><tr id="17e0aa8f_190"><td id="17e0aa8f_191"><p>Hash</p></td><td id="17e0aa8f_192"><p>类似Map的一种结构</p></td><td id="17e0aa8f_193"><p>采用hashtable或者ziplist进行具体实现</p></td></tr><tr id="17e0aa8f_194"><td id="17e0aa8f_195"><p>List</p></td><td id="17e0aa8f_196"><p>有序列表</p></td><td id="17e0aa8f_197"><p>采用intset或者hashtable存储</p></td></tr><tr id="17e0aa8f_198"><td id="17e0aa8f_199"><p>Set</p></td><td id="17e0aa8f_200"><p>无序集合，成员唯一</p></td><td id="17e0aa8f_201"><p>采用ziplist或者skiplist + hashtable实现</p></td></tr><tr id="17e0aa8f_202"><td id="17e0aa8f_203"><p>ZSet</p></td><td id="17e0aa8f_204"><p>带权值的无序集合，即每个ZSet元素还带有另外一个数字代表权值，集合通过权值进行排序</p></td><td id="17e0aa8f_205"></td></tr></tbody ></table ></div></section><section class="chapter"><h3 id="redis" data-toc="redis">三、什么情况下使用Redis</h3><ol class="list _decimal" id="17e0aa8f_206"  type="1"  ><li class="list__item" id="17e0aa8f_207"><p>针对热点数据进行缓存</p></li><li class="list__item" id="17e0aa8f_208"><p>对特定限时数据的存放</p></li><li class="list__item" id="17e0aa8f_209"><p>针对带热点权值数据排序的list</p></li><li class="list__item" id="17e0aa8f_210"><p>分布式锁</p></li></ol></section><section class="chapter"><h3 id="17e0aa8f_211" data-toc="17e0aa8f_211">四、缓存的一些问题</h3><section class="chapter"><h4 id="1" data-toc="1">1）缓存穿透</h4><section class="chapter"><h5 id="17e0aa8f_212" data-toc="17e0aa8f_212">简述</h5><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_213"><p id="17e0aa8f_214">缓存和数据库都没有需要查询的数据，攻击者不断地发送这种请求，使数据库压力过大</p></aside></section><section class="chapter"><h5 id="17e0aa8f_215" data-toc="17e0aa8f_215">解决</h5><ol class="list _decimal" id="17e0aa8f_216"  type="1"  ><li class="list__item" id="17e0aa8f_217"><p>对数据库操作访问前进行校验，对不合法数据直接返回。bitmap</p></li><li class="list__item" id="17e0aa8f_218"><p>对于经常被访问的，并且数据库没有的键，缓存层记录键=null</p></li></ol></section></section><section class="chapter"><h4 id="2" data-toc="2">2）缓存击穿</h4><section class="chapter"><h5 id="17e0aa8f_219" data-toc="17e0aa8f_219">简述</h5><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_220"><p id="17e0aa8f_221">缓存中没有数据，但数据库中有该数据。</p><p id="17e0aa8f_222">一般是由于特定数据的缓存时间到期。且当并发访问该数据的用户特别多，因此去数据库取数据导致压力过大</p></aside></section><section class="chapter"><h5 id="17e0aa8f_223" data-toc="17e0aa8f_223">解决</h5><ol class="list _decimal" id="17e0aa8f_224"  type="1"  ><li class="list__item" id="17e0aa8f_225"><p>设置热点数据永不过期</p></li><li class="list__item" id="17e0aa8f_226"><p>对并发数据设置并发锁，降低并发性</p></li></ol></section></section><section class="chapter"><h4 id="3" data-toc="3">3）缓存雪崩</h4><section class="chapter"><h5 id="17e0aa8f_227" data-toc="17e0aa8f_227">简述</h5><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_228"><p id="17e0aa8f_229">一大批数据到过期时间，而从缓存中删除，但该批数据量巨大，查询全部数据库，造成数据库压力过大</p></aside></section><section class="chapter"><h5 id="17e0aa8f_230" data-toc="17e0aa8f_230">解决</h5><ol class="list _decimal" id="17e0aa8f_231"  type="1"  ><li class="list__item" id="17e0aa8f_232"><p>缓存数据设置随机过期时间，防止同一时间大量数据过期</p></li><li class="list__item" id="17e0aa8f_233"><p>设置热点数据永不过期</p></li><li class="list__item" id="17e0aa8f_234"><p>对于集群部署的情况，将热点数据均匀分布到不同的缓存中</p></li></ol></section></section></section><section class="chapter"><h3 id="redis" data-toc="redis">五、Redis集群部署方式</h3><ol class="list _decimal" id="17e0aa8f_235"  type="1"  ><li class="list__item" id="17e0aa8f_236"><p>主从复制</p></li><li class="list__item" id="17e0aa8f_237"><p>哨兵模式</p></li><li class="list__item" id="17e0aa8f_238"><p>Cluster集群模式</p></li></ol></section><section class="chapter"><h3 id="redis" data-toc="redis">六、Redis的备份</h3><section class="chapter"><h4 id="1-rdb" data-toc="1-rdb">1）RDB</h4><ol class="list _decimal" id="17e0aa8f_239"  type="1"  ><li class="list__item" id="17e0aa8f_240"><p>生成当前数据的快照，并保存在硬盘中，可以通过手动命令，也可以设置自动触发</p></li><li class="list__item" id="17e0aa8f_241"><p>save命令：手动出发RDB过程的命令。使用之后，服务器阻塞，直到RDB过程完成后终止，该过程占用内存较多</p></li><li class="list__item" id="17e0aa8f_242"><p>bgsave命令：不完全阻塞主线程，该命令fork一个子进程用于执行RDB过程。其具体过程为： </p><ol class="list _decimal" id="17e0aa8f_243"  type="1"  ><li class="list__item" id="17e0aa8f_244"><p>判断此时又没有子进程用于RDB，有的话直接返回</p></li><li class="list__item" id="17e0aa8f_245"><p>Redis进行fork子进程过程，此时父进程处于阻塞状态</p></li><li class="list__item" id="17e0aa8f_246"><p>子进程创建RDB文件，完成后返回给父进程</p></li></ol></li><li class="list__item" id="17e0aa8f_247"><p>自动触发RDB机制 </p><ol class="list _decimal" id="17e0aa8f_248"  type="1"  ><li class="list__item" id="17e0aa8f_249"><p>通过配置文件，设置一定时间后自动执行RDB</p></li><li class="list__item" id="17e0aa8f_250"><p>如采用主从复制过程，会自动执行RDB</p></li><li class="list__item" id="17e0aa8f_251"><p>Redis执行shutdown时，在未开启AOF后会执行RDB</p></li></ol></li></ol></section><section class="chapter"><h4 id="2-aof" data-toc="2-aof">2）AOF</h4><ol class="list _decimal" id="17e0aa8f_252"  type="1"  ><li class="list__item" id="17e0aa8f_253"><p>AOF通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF</p></li><li class="list__item" id="17e0aa8f_254"><p>持久化策略 </p><ol class="list _decimal" id="17e0aa8f_255"  type="1"  ><li class="list__item" id="17e0aa8f_256"><p>always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上</p></li><li class="list__item" id="17e0aa8f_257"><p>everysec。每秒将命令写入到磁盘日志上</p></li><li class="list__item" id="17e0aa8f_258"><p>no。不主动设置，有操作系统决定什么时候写入到磁盘文件上</p></li></ol></li><li class="list__item" id="17e0aa8f_259"><p>AOF重写 </p><ol class="list _decimal" id="17e0aa8f_260"  type="1"  ><li class="list__item" id="17e0aa8f_261"><p>随着客户端的不断进行操作，AOF文件也越来越大。Redis提供了bgrewriteaof函数，针对目前数据库数据，在不读取原有AOF文件的基础上，重写了一个新的AOF文件，减少了文件大小。（<span class="control" id="17e0aa8f_262">去除中间过程</span>）</p></li></ol></li></ol></section><section class="chapter"><h4 id="3" data-toc="3">3）优缺点</h4><ol class="list _decimal" id="17e0aa8f_263"  type="1"  ><li class="list__item" id="17e0aa8f_264"><p>AOF占用的文件体积比RDB大</p></li><li class="list__item" id="17e0aa8f_265"><p>一般来说AOF备份对系统的消耗比RDB低。</p></li><li class="list__item" id="17e0aa8f_266"><p>对于备份时出现系统故障，RDB数据可能全丢，但AOF只会损失一部分</p></li><li class="list__item" id="17e0aa8f_267"><p>RDB恢复速度比AOF低</p></li></ol></section></section><section class="chapter"><h3 id="17e0aa8f_268" data-toc="17e0aa8f_268">七、淘汰机制</h3><ol class="list _decimal" id="17e0aa8f_269"  type="1"  ><li class="list__item" id="17e0aa8f_270"><p>noeviction：默认禁止驱逐数据。内存不够使用时，对申请内存的命令报错。</p></li><li class="list__item" id="17e0aa8f_271"><p>volatile-lru：从设置了过期时间的数据集中淘汰最近没使用的数据。</p></li><li class="list__item" id="17e0aa8f_272"><p>volatile-ttl：从设置了过期时间的数据集中淘汰即将要过期的数据。</p></li><li class="list__item" id="17e0aa8f_273"><p>volatile-random：从设置了过期时间的数据中随机淘汰数据。</p></li><li class="list__item" id="17e0aa8f_274"><p>allkeys-lru：淘汰最近没使用的数据。</p></li><li class="list__item" id="17e0aa8f_275"><p>allkeys-random：随机淘汰数据</p></li></ol></section><section class="chapter"><h3 id="17e0aa8f_276" data-toc="17e0aa8f_276">八、过期策略</h3><ol class="list _decimal" id="17e0aa8f_277"  type="1"  ><li class="list__item" id="17e0aa8f_278"><p>定期删除：redis默认是每100ms就随机抽取一些设置了过期时间的key，并检查是否过期，如果过期就会删除。因此该删除策略并不会删除所有的过期key</p></li><li class="list__item" id="17e0aa8f_279"><p>惰性删除：在客户端需要获取某个key时，redis会先对其进行检查，如果key设置了过期时间且已经过期就会删除</p></li><li class="list__item" id="17e0aa8f_280"><p>实际上，redis结合两种手段，保证删除过期的key</p></li></ol></section><section class="chapter"><h3 id="redis" data-toc="redis">九、Redis快的原因</h3><ol class="list _decimal" id="17e0aa8f_281"  type="1"  ><li class="list__item" id="17e0aa8f_282"><p>Redis是基于内存的数据库，内存数据读取存储效率远大于硬盘型</p></li><li class="list__item" id="17e0aa8f_283"><p>Redis采用多路复用技术通过而epoll的非阻塞IO，提升了效率</p></li></ol></section></section><section class="chapter"><h2 id="17e0aa8f_284" data-toc="17e0aa8f_284">命令</h2><div class="table-wrapper" ><table class="wide" id="17e0aa8f_285"  ><thead><tr class="ijRowHead" id="17e0aa8f_286"><th id="17e0aa8f_287"><p>命令</p></th><th id="17e0aa8f_288"><p>说明</p></th><th id="17e0aa8f_289"><p>用法</p></th></tr></thead><tbody ><tr id="17e0aa8f_290"><td id="17e0aa8f_291"><p>SETNX</p></td><td id="17e0aa8f_292"><p>set if not exists</p></td><td id="17e0aa8f_293"><p>setnx key [seconds] value</p></td></tr><tr id="17e0aa8f_294"><td id="17e0aa8f_295"><p>PSETNX</p></td><td id="17e0aa8f_296"><p>set</p></td><td id="17e0aa8f_297"><p>psetnx key milliseconds value</p></td></tr></tbody ></table ></div><section class="chapter"><h3 id="keys" data-toc="keys">keys</h3><ol class="list _decimal" id="17e0aa8f_298"  type="1"  ><li class="list__item" id="17e0aa8f_299"><p>keys命令是通过遍历全部db下的key再过滤实现的</p></li><li class="list__item" id="17e0aa8f_300"><p>keys命令没有汇总各节点查询结果的逻辑，不会路由keys命令</p></li><li class="list__item" id="17e0aa8f_301"><p>设计目的是 调试或者特殊用途的，不适用于生产环境。</p></li><li class="list__item" id="17e0aa8f_302"><p>可以使用<code class="code" id="17e0aa8f_303">SCAN</code> 或者 <code class="code" id="17e0aa8f_304">sets</code></p></li></ol></section></section><section class="chapter"><h2 id="17e0aa8f_305" data-toc="17e0aa8f_305">分布式锁</h2><section class="chapter"><h3 id="17e0aa8f_306" data-toc="17e0aa8f_306">特性</h3><ol class="list _decimal" id="17e0aa8f_307"  type="1"  ><li class="list__item" id="17e0aa8f_308"><p>互斥性</p></li><li class="list__item" id="17e0aa8f_309"><p>高可用性</p></li><li class="list__item" id="17e0aa8f_310"><p>防止锁超时</p></li><li class="list__item" id="17e0aa8f_311"><p>独占性</p></li></ol></section><section class="chapter"><h3 id="17e0aa8f_312" data-toc="17e0aa8f_312">实现分布式锁有哪些坑</h3><ol class="list _decimal" id="17e0aa8f_313"  type="1"  ><li class="list__item" id="17e0aa8f_314"><p>不是原子操作</p></li><li class="list__item" id="17e0aa8f_315"><p>没有释放锁</p></li><li class="list__item" id="17e0aa8f_316"><p>释放了锁，但业务还没有执行完</p></li><li class="list__item" id="17e0aa8f_317"><p>释放了别人的锁</p></li><li class="list__item" id="17e0aa8f_318"><p>大量请求竞争锁失败</p></li><li class="list__item" id="17e0aa8f_319"><p>多节点Redis主从复制问题</p></li><li class="list__item" id="17e0aa8f_320"><p>高并发下锁的性能问题</p></li></ol></section></section><section class="chapter"><h2 id="websites" data-toc="websites">Websites</h2><ol class="list _decimal" id="17e0aa8f_321"  type="1"  ><li class="list__item" id="17e0aa8f_322"><p><a href="https://launchpad.redis.com/" id="17e0aa8f_323"   data-external="true" rel="noopener noreferrer" >Redis Launchpad</a></p></li></ol><aside class="prompt" data-type="tip" data-title="" id="17e0aa8f_324"><p id="17e0aa8f_325">Redis官方的用户展示厅，展示各种使用 Redis 的网络应用，并有用法和架构的讲解</p></aside><ol class="list _decimal" id="17e0aa8f_326"  type="1"  start="2"><li class="list__item" id="17e0aa8f_327"></li></ol></section><div class="last-modified"> Last modified: 28 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="spring.html">Spring</a>   <a class="navigation-links__next" href="other.html">OAuth</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>