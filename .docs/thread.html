<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2023-11-28T23:26:37.6596098"><meta name="build-number" content="${buildNumber}">       <title>线程 | Yui</title><script id="virtual-toc-data" type="application/json">[{"id":"1eb5b892_92","level":0,"title":"线程和进程","anchor":"#1eb5b892_92"},{"id":"1eb5b892_96","level":0,"title":"线程池","anchor":"#1eb5b892_96"},{"id":"thread","level":0,"title":"Thread","anchor":"#thread"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="线程 | Yui"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Yui Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="thread.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="线程 | Yui"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "thread.html#webpage", "url": "thread.html", "name": "线程 | Yui", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Yui Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Thread" data-main-title="线程" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="java"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Yui  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Thread"  id="Thread.md"  >线程</h1>  <section class="chapter"><h2 id="1eb5b892_92" data-toc="1eb5b892_92">线程和进程</h2><ol class="list _decimal" id="1eb5b892_93"  type="1"  ><li class="list__item" id="1eb5b892_94"><p>进程是操作系统资源分配的基本单位</p></li><li class="list__item" id="1eb5b892_95"><p>线程是处理器任务调度和执行的基本单位</p></li></ol></section><section class="chapter"><h2 id="1eb5b892_96" data-toc="1eb5b892_96">线程池</h2><section class="chapter"><h3 id="uml" data-toc="uml">UML</h3><figure  id="1eb5b892_97"><img alt="java.util.concurrent.Executor" title="java.util.concurrent.Executor" src="images/Executor.png"  class="" width="4066" height="788"/></figure></section><section class="chapter"><h3 id="1eb5b892_98" data-toc="1eb5b892_98">参数</h3><ol class="list _decimal" id="1eb5b892_99"  type="1"  ><li class="list__item" id="1eb5b892_100"><p>corePoolSize 核心线程大小</p></li><li class="list__item" id="1eb5b892_101"><p>maximumPoolSize 最大线程数量</p></li><li class="list__item" id="1eb5b892_102"><p>workQueue 队列长度</p></li></ol><aside class="prompt" data-type="tip" data-title="" id="1eb5b892_103"><p id="1eb5b892_104">创建线程时，如果当前线程数量没有到corePoolSize，则会创建线程；核心线程空闲也不会被销毁。 当达到corePoolSize，则会进入workQueue； 当队列已满，则会创建线程直至maximumPoolSize</p></aside></section><section class="chapter"><h3 id="1eb5b892_105" data-toc="1eb5b892_105">线程池的两种提交任务方式区别</h3><ul class="list _ul" id="1eb5b892_106"    ><li class="list__item" id="1eb5b892_107"><p>execute只能提交Runnable，无返回值 </p><ul class="list _ul" id="1eb5b892_108"    ><li class="list__item" id="1eb5b892_109"><p>ThreadPoolExecutor.java</p></li></ul></li><li class="list__item" id="1eb5b892_110"><p>submit既可以提交Runnable，返回值null；也可以提交Callable，返回值Future </p><ul class="list _ul" id="1eb5b892_111"    ><li class="list__item" id="1eb5b892_112"><p>AbstractExecutorService.java</p></li><li class="list__item" id="1eb5b892_113"><p>Callable是设置如何产生结果，Future用来获取结果</p></li></ul></li><li class="list__item" id="1eb5b892_114"><p>执行遇到异常 </p><ul class="list _ul" id="1eb5b892_115"    ><li class="list__item" id="1eb5b892_116"><p>execute 会直接抛出，可以通过Thread::setUncaughtExceptionHandler来处理</p></li><li class="list__item" id="1eb5b892_117"><p>submit 不会直接抛出，需要使用Future.get()回去返回值时才抛出。</p></li></ul></li></ul></section><section class="chapter"><h3 id="executors" data-toc="executors">Executors</h3><section class="chapter"><h4 id="1eb5b892_118" data-toc="1eb5b892_118">类型</h4><ol class="list _decimal" id="1eb5b892_119"  type="1"  ><li class="list__item" id="1eb5b892_120"><p>SingleThreadExecutor：单线程的线程池</p></li><li class="list__item" id="1eb5b892_121"><p>FixedThreadPool：固定大小的线程池</p></li><li class="list__item" id="1eb5b892_122"><p>CachedThreadPool：核心线程数为0，可以服用之前创建但现在空闲的线程的线程池</p></li><li class="list__item" id="1eb5b892_123"><p>ScheduledThreadPool：支持定时及周期性执行任务的线程池</p></li><li class="list__item" id="1eb5b892_124"><p>WorkingStealingPool：java1.8之后，自动调用系统可用的线程数，并行执行任务</p></li></ol></section><section class="chapter"><h4 id="1eb5b892_125" data-toc="1eb5b892_125">弊端</h4><ol class="list _decimal" id="1eb5b892_126"  type="1"  ><li class="list__item" id="1eb5b892_127"><p><code class="code" id="1eb5b892_128">FixedThreadPool</code>和<code class="code" id="1eb5b892_129">SingleThreadPool</code> ：允许请求的队列长度为Integer.MAX_VALUE，可能会堆积大量请求，导致oom</p></li><li class="list__item" id="1eb5b892_130"><p><code class="code" id="1eb5b892_131">CachedThreadPool</code> ：允许创建的线程数量为Integer.MAX_VALUE，可能 创建大量线程，导致oom</p></li></ol><aside class="prompt" data-type="tip" data-title="" id="1eb5b892_132"><p id="1eb5b892_133">推荐通过<code class="code" id="1eb5b892_134">ThreadPoolExecutor</code>方式来实现线程池</p></aside></section></section><section class="chapter"><h3 id="threadpoolexecutor" data-toc="threadpoolexecutor">ThreadPoolExecutor</h3><section class="chapter"><h4 id="execute" data-toc="execute">execute方法</h4><aside class="prompt" data-type="tip" data-title="" id="1eb5b892_135"><p id="1eb5b892_136">Proceed in 3 steps:</p><ol class="list _decimal" id="1eb5b892_137"  type="1"  ><li class="list__item" id="1eb5b892_138"><p id="1eb5b892_139">If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false.</p></li><li class="list__item" id="1eb5b892_140"><p id="1eb5b892_141">If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none.</p></li><li class="list__item" id="1eb5b892_142"><p id="1eb5b892_143">If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task.</p></li></ol></aside></section><section class="chapter"><h4 id="1eb5b892_144" data-toc="1eb5b892_144">拒绝策略</h4><ul class="list _ul" id="1eb5b892_145"    ><li class="list__item" id="1eb5b892_146"><p>RejectedExecutionHandler，任务处理不过来时，拒绝策略</p></li></ul><div class="code-block" data-lang="java"         >
import java.util.concurrent.ThreadPoolExecutor;

public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
</div><ol class="list _decimal" id="1eb5b892_148"  type="1"  ><li class="list__item" id="1eb5b892_149"><p>new ThreadPoolExecutor.AbortPolicy() </p><ol class="list _decimal" id="1eb5b892_150"  type="1"  ><li class="list__item" id="1eb5b892_151"><p>直接抛异常</p></li></ol></li><li class="list__item" id="1eb5b892_152"><p>new ThreadPoolExecutor.CallerRunsPolicy() </p><ol class="list _decimal" id="1eb5b892_153"  type="1"  ><li class="list__item" id="1eb5b892_154"><p>线程池如果未关闭，直接执行run方法</p></li></ol></li><li class="list__item" id="1eb5b892_155"><p>new ThreadPoolExecutor.DiscardPolicy() </p><ol class="list _decimal" id="1eb5b892_156"  type="1"  ><li class="list__item" id="1eb5b892_157"><p>新任务直接丢弃</p></li></ol></li><li class="list__item" id="1eb5b892_158"><p>new ThreadPoolExecutor.DiscardOldestPolicy() </p><ol class="list _decimal" id="1eb5b892_159"  type="1"  ><li class="list__item" id="1eb5b892_160"><p>线程池等待任务移除队列头部元素（poll()方法），将新任务加到队列中</p></li></ol></li><li class="list__item" id="1eb5b892_161"><p>自定义策略，比如持久化多余的线程，用定时任务把持久化线程取出</p></li></ol></section></section></section><section class="chapter"><h2 id="thread" data-toc="thread">Thread</h2><section class="chapter"><h3 id="sleep-wait" data-toc="sleep-wait">sleep方法和wait方法区别</h3><ol class="list _decimal" id="1eb5b892_162"  type="1"  ><li class="list__item" id="1eb5b892_163"><p>所属类和方法类型不同：Thread.sleep() ; new Object().wait()</p></li><li class="list__item" id="1eb5b892_164"><p>使用语法不同： </p><ol class="list _decimal" id="1eb5b892_165"  type="1"  ><li class="list__item" id="1eb5b892_166"><p>sleep可以直接使用</p></li><li class="list__item" id="1eb5b892_167"><p>wait方法需要先拿到锁，才可以调object.wait()</p></li></ol></li><li class="list__item" id="1eb5b892_168"><p>唤醒方式不同 </p><ol class="list _decimal" id="1eb5b892_169"  type="1"  ><li class="list__item" id="1eb5b892_170"><p>sleep 需要指定时间</p></li><li class="list__item" id="1eb5b892_171"><p>wait 可以传时间，也可以不传时间；或者使用notify() /notifyAll()</p></li></ol></li><li class="list__item" id="1eb5b892_172"><p>释放锁资源不同 </p><ol class="list _decimal" id="1eb5b892_173"  type="1"  ><li class="list__item" id="1eb5b892_174"><p>sleep 休眠时不会释放锁资源</p></li><li class="list__item" id="1eb5b892_175"><p>wait 休眠时会释放锁资源</p></li></ol></li><li class="list__item" id="1eb5b892_176"><p>线程状态不同 </p><ol class="list _decimal" id="1eb5b892_177"  type="1"  ><li class="list__item" id="1eb5b892_178"><p>sleep: TIMED_WAITING</p></li><li class="list__item" id="1eb5b892_179"><p>wait: WAITING</p></li></ol></li></ol></section></section><div class="last-modified"> Last modified: 28 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="yolo.html">Yolo</a>   <a class="navigation-links__next" href="otheraspect.html">其他</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>