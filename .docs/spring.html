<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2023-11-28T23:26:37.6596098"><meta name="build-number" content="${buildNumber}">       <title>Spring | Yui</title><script id="virtual-toc-data" type="application/json">[{"id":"aop","level":0,"title":"AOP","anchor":"#aop"},{"id":"springioc","level":0,"title":"SpringIOC","anchor":"#springioc"},{"id":"bean","level":0,"title":"Bean","anchor":"#bean"},{"id":"40786019_438","level":0,"title":"注解","anchor":"#40786019_438"},{"id":"40786019_555","level":0,"title":"依赖","anchor":"#40786019_555"},{"id":"40786019_575","level":0,"title":"事务","anchor":"#40786019_575"},{"id":"other","level":0,"title":"Other","anchor":"#other"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Spring | Yui"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Yui Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="spring.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Spring | Yui"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "spring.html#webpage", "url": "spring.html", "name": "Spring | Yui", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Yui Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Spring" data-main-title="Spring" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="framework"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Yui  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Spring"  id="Spring.md"  >Spring</h1>  <section class="chapter"><h2 id="aop" data-toc="aop">AOP</h2><section class="chapter"><h3 id="40786019_343" data-toc="40786019_343">简述</h3><ol class="list _decimal" id="40786019_344"  type="1"  ><li class="list__item" id="40786019_345"><p>概念：Aspect-Oriented Programming，一般称为面向切面编程。</p></li><li class="list__item" id="40786019_346"><p>目的：用于将那些与业务无关的，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被称为切面（Aspect）</p></li><li class="list__item" id="40786019_347"><p>用途：权限认证、日志、事务处理等，作为面向对象的一种补充</p></li><li class="list__item" id="40786019_348"><p>好处：减少重复代码，提高系统可维护性，降低模块间的耦合度</p></li><li class="list__item" id="40786019_349"><p>原理：使用的是动态代理</p></li></ol></section><section class="chapter"><h3 id="40786019_350" data-toc="40786019_350">动态代理</h3><section class="chapter"><h4 id="jdk" data-toc="jdk">JDK动态代理</h4><ol class="list _decimal" id="40786019_351"  type="1"  ><li class="list__item" id="40786019_352"><p><span class="control" id="40786019_353">只提供接口代理，不支持类代理</span></p></li><li class="list__item" id="40786019_354"><p>运行时生成动态代理类 $proxy.class</p></li><li class="list__item" id="40786019_355"><p>代理类实现了目标类接口，并且实现接口类所有方法增强代码</p></li><li class="list__item" id="40786019_356"><p>调用时，通过代理类先去调用处理类进行增强，再通过反射方式调用目标类的方法，从而实现AOP</p></li></ol></section><section class="chapter"><h4 id="cglib" data-toc="cglib">CGLIB动态代理</h4><ol class="list _decimal" id="40786019_357"  type="1"  ><li class="list__item" id="40786019_358"><p><span class="control" id="40786019_359">没有实现接口</span></p></li><li class="list__item" id="40786019_360"><p>通过<span class="control" id="40786019_361">ASM</span>在运行时动态生成目标类的一个<span class="control" id="40786019_362">子类</span> ，(还有相关类，主要是为了增强调用时效率)会生成多个</p></li><li class="list__item" id="40786019_363"><p>会重写<span class="control" id="40786019_364">父类</span>所有的方法增强代码</p></li><li class="list__item" id="40786019_365"><p>调用时，先代理类进行增强，再<span class="control" id="40786019_366">直接调用父类对应方法</span> ，从而实现AOP </p><ol class="list _decimal" id="40786019_367"  type="1"  ><li class="list__item" id="40786019_368"><p>类被标记为final，无法使用CGLIB做动态代理的</p></li><li class="list__item" id="40786019_369"><p>除了目标子类代理类，还有个FastClass（路由类），可以（但不是必须）让本类方法调用进行增强，不会像jdk代理</p></li></ol></li></ol><aside class="prompt" data-type="tip" data-title="" id="40786019_370"><p id="40786019_371">jdk生成类速度快，调用慢，cglib生成类速度慢，调用快。但jdk版本升级优化，cglib止步不前。 jdk性能比cglib好</p></aside></section><section class="chapter"><h4 id="40786019_372" data-toc="40786019_372">相关方法</h4><ol class="list _decimal" id="40786019_373"  type="1"  ><li class="list__item" id="40786019_374"><p>是否是代理对象: <code class="code" id="40786019_375">AopUtils.isAopProxy(AopContext.currentProxy());</code></p></li><li class="list__item" id="40786019_376"><p>是否是cglib代理对象: <code class="code" id="40786019_377">AopUtils.isCglibProxy(AopContext.currentProxy())</code></p></li><li class="list__item" id="40786019_378"><p>是否是jdk代理对象: <code class="code" id="40786019_379">AopUtils.isJdkDynamicProxy(AopContext.currentProxy());</code></p></li></ol></section></section><section class="chapter"><h3 id="40786019_380" data-toc="40786019_380">相关名词</h3><ol class="list _decimal" id="40786019_381"  type="1"  ><li class="list__item" id="40786019_382"><p>切面 Aspect 切面类，管理切点和通知</p></li><li class="list__item" id="40786019_383"><p>连接点 Join Point 被增强的业务方法</p></li><li class="list__item" id="40786019_384"><p>通知 Advice 需要增加到业务方法中的公共代码和逻辑</p></li><li class="list__item" id="40786019_385"><p>切点 Pointcut 决定那些方法需要增强，那些不需要。结合切点表达式</p></li><li class="list__item" id="40786019_386"><p>目标对象 Target Object 增强的对象</p></li><li class="list__item" id="40786019_387"><p>织入 Weaving Aspectj独有的，Spring aop织入方式是动态代理。 </p><ol class="list _decimal" id="40786019_388"  type="1"  ><li class="list__item" id="40786019_389"><p>编译器</p></li><li class="list__item" id="40786019_390"><p>类加载期</p></li><li class="list__item" id="40786019_391"><p>运行期</p></li></ol></li><li class="list__item" id="40786019_392"><p>其他 </p><ol class="list _decimal" id="40786019_393"  type="1"  ><li class="list__item" id="40786019_394"><p>Advisor 顾问。是Pointcut和Advice的一个结合</p></li></ol></li></ol></section><section class="chapter"><h3 id="aspectj" data-toc="aspectj">AspectJ</h3><section class="chapter"><h4 id="spring-aop" data-toc="spring-aop">Spring AOP使用</h4><ol class="list _decimal" id="40786019_395"  type="1"  ><li class="list__item" id="40786019_396"><p>Spring AOP 提供了AspectJ的支持，</p></li><li class="list__item" id="40786019_397"><p>但只用到了AspectJ的切点解析和匹配，及@Aspect、@Before等注解</p></li><li class="list__item" id="40786019_398"><p>在容器启动时需要生成代理实例，在方法的调用上也会增加栈的深度，使得Spring AOP 性能没有AspectJ那么好</p></li></ol></section><section class="chapter"><h4 id="aspectj" data-toc="aspectj">AspectJ本身</h4><aside class="prompt" data-type="tip" data-title="" id="40786019_399"><p id="40786019_400">AspectJ 是静态代理增强，编译阶段生成AOP代理类，编译时增强。 编译阶段将切面织入到Java字节码中，运行的是增强后的AOP对象 使用的话，需要使用AspectJ编译器。 <code class="code" id="40786019_401">xxx.aj; aspect</code></p></aside></section></section></section><section class="chapter"><h2 id="springioc" data-toc="springioc">SpringIOC</h2><section class="chapter"><h3 id="40786019_402" data-toc="40786019_402">控制反转</h3><ol class="list _decimal" id="40786019_403"  type="1"  ><li class="list__item" id="40786019_404"><p>new实例类，耦合度太高，维护不方便</p></li><li class="list__item" id="40786019_405"><p>引入IOC，将创建对象控制权交给了Spring，控制了对象的创建权利，Spring IOC去创建</p></li><li class="list__item" id="40786019_406"><p>要使用对象：需要通过DI（依赖注入）@Autowired，从容器中自动注入</p></li></ol></section><section class="chapter"><h3 id="40786019_407" data-toc="40786019_407">优点</h3><aside class="prompt" data-type="tip" data-title="" id="40786019_408"><p id="40786019_409">集中管理对象，方便维护，降低耦合度</p></aside></section><section class="chapter"><h3 id="40786019_410" data-toc="40786019_410">实现机制</h3><section class="chapter"><h4 id="40786019_411" data-toc="40786019_411">工厂模式</h4><p id="40786019_412"><code class="code" id="40786019_413">BeanFactory.getBean(String beanName)</code></p></section><section class="chapter"><h4 id="40786019_414" data-toc="40786019_414">反射</h4><p id="40786019_415">通过反射，实例化创建Bean对象 <code class="code" id="40786019_416">BeanFactory.getBean(String className)</code></p></section></section></section><section class="chapter"><h2 id="bean" data-toc="bean">Bean</h2><section class="chapter"><h3 id="40786019_418" data-toc="40786019_418">作用域</h3><p id="40786019_419">作用域：Prototype/Singleton/Request/Session/Global Session</p><ul class="list _ul" id="40786019_420"    ><li class="list__item" id="40786019_421"><p>Prototype：原型模式，每次获取bean都会创建以一个新的实例，因此不存在线程安全的问题。</p></li><li class="list__item" id="40786019_422"><p>Singleton：不同的线程访问同一个bean，如果这个bean中含有实例变量，并且线程具有对实例变量的写操作时，就会产生线程安全问题 </p><ul class="list _ul" id="40786019_423"    ><li class="list__item" id="40786019_424"><p>解决：使用<a href="concurrence.html" id="40786019_425" data-tooltip="控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源"  >ThreadLocal</a> ，为每个线程创建独立的变量副本，互相隔离互不影响</p></li></ul></li><li class="list__item" id="40786019_426"><p>只要Bean是无状态的则一定是线程安全的</p></li></ul></section><section class="chapter"><h3 id="40786019_427" data-toc="40786019_427">加载方式</h3><ol class="list _decimal" id="40786019_428"  type="1"  ><li class="list__item" id="40786019_429"><p>使用<code class="code" id="40786019_430">@Component</code>注解 和<code class="code" id="40786019_431">@ComponentScan</code>对其进行扫描</p></li><li class="list__item" id="40786019_432"><p>在配置类中(<code class="code" id="40786019_433">@Configuration</code> )，使用<code class="code" id="40786019_434">@Bean</code>注解，将方法返回值加载到容器中</p></li><li class="list__item" id="40786019_435"><p>类上声明<code class="code" id="40786019_436">@Import(User.class)</code></p></li></ol></section></section><section class="chapter"><h2 id="40786019_438" data-toc="40786019_438">注解</h2><section class="chapter"><h3 id="autowired" data-toc="autowired">Autowired</h3><section class="chapter"><h4 id="required" data-toc="required">required属性</h4><ul class="list _ul" id="40786019_439"    ><li class="list__item" id="40786019_440"><p><span class="control" id="40786019_441">@Autowired(required = true)</span></p><ul class="list _ul" id="40786019_442"    ><li class="list__item" id="40786019_443"><p>默认是true，表示注入的时候，该bean必须存在，否则会注入失败</p></li></ul></li><li class="list__item" id="40786019_444"><p><span class="control" id="40786019_445">@Autowired(required = false)</span></p><ul class="list _ul" id="40786019_446"    ><li class="list__item" id="40786019_447"><p>忽略当前要注入bean，如果有直接注入，没有跳过，不会报错</p></li></ul></li><li class="list__item" id="40786019_448"><p>容器启动过程中，会初始化bean，spring核心之一（IOC）</p></li><li class="list__item" id="40786019_449"><p><span id="40786019_450" ><span class="text-line-through">当前容器不能注入自己，这样就会不停的注入自己，陷入死循环，从而找不到要注入的bean</span></span></p><ul class="list _ul" id="40786019_451"    ><li class="list__item" id="40786019_452"><p>Spring框架提供的三级缓存来专门解决循环依赖</p></li><li class="list__item" id="40786019_453"><p>构造函数注入会进入死循环</p></li></ul></li></ul></section><section class="chapter"><h4 id="40786019_454" data-toc="40786019_454">依赖注入方式</h4><section class="chapter"><h5 id="field-injection" data-toc="field-injection">一、Field Injection</h5><aside class="prompt" data-type="tip" data-title="" id="40786019_455"><p id="40786019_456"><span class="control" id="40786019_457">@Autowired</span></p><p id="40786019_458">通过Java反射机制实现，所以private成员也可以被注入具体的对象</p><div class="code-block" data-lang="java"         >
@Controller
public class UserController {
 @Autowired
 private UserService userService;
}
</div></aside></section><section class="chapter"><h5 id="construction-injection" data-toc="construction-injection">二、Construction Injection （推荐）</h5><aside class="prompt" data-type="tip" data-title="" id="40786019_460"><p id="40786019_461">通过对象构造的时候建立关系，所以对对象创建的顺序有要求。当然Spring会为你搞定这样的先后顺序，除非出现循环依赖，然后就会抛出异常</p><div class="code-block" data-lang="java"         >
@Controller
public class UserController {
 private final UserService userService;
 public UserController(UserService userService) {
     this.userService = userService;
 }
}
</div></aside></section><section class="chapter"><h5 id="setter-injection" data-toc="setter-injection">三、Setter Injection</h5><aside class="prompt" data-type="tip" data-title="" id="40786019_463"><ol class="list _decimal" id="40786019_464"  type="1"  ><li class="list__item" id="40786019_465"><p>也会用到@Autowired注解，</p></li><li class="list__item" id="40786019_466"><p>但使用方式与<span class="control" id="40786019_467">Filed Injection</span>有所不同，Field Injection是用在成员变量上的，而Setter Injection是用在Setter函数上的。</p></li><li class="list__item" id="40786019_468"><p>就是通过调用成员变量的set方法来注入想要使用的依赖对象</p></li><li class="list__item" id="40786019_469"><p>相较于 <span class="control" id="40786019_470">Field Injection</span> 测试性更好</p></li></ol><div class="code-block" data-lang="java"         >
@Controller
public class UserController {
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
</div></aside></section><section class="chapter"><h5 id="40786019_472" data-toc="40786019_472">对比</h5><div class="table-wrapper" ><table class="wide" id="40786019_473"  ><thead><tr class="ijRowHead" id="40786019_474"><th id="40786019_475"><p>注入方式</p></th><th id="40786019_476"><p>可靠性</p></th><th id="40786019_477"><p>可维护性</p></th><th id="40786019_478"><p>可测试性</p></th><th id="40786019_479"><p>灵活性</p></th><th id="40786019_480"><p>循环关系检测</p></th><th id="40786019_481"><p>性能影响</p></th></tr></thead><tbody ><tr id="40786019_482"><td id="40786019_483"><p>Field Injection</p></td><td id="40786019_484"><p>不可靠</p></td><td id="40786019_485"><p>差</p></td><td id="40786019_486"><p>差</p></td><td id="40786019_487"><p>灵活</p></td><td id="40786019_488"><p>不检测</p></td><td id="40786019_489"><p>启动快</p></td></tr><tr id="40786019_490"><td id="40786019_491"><p>Constructor Injection</p></td><td id="40786019_492"><p>可靠</p></td><td id="40786019_493"><p>好</p></td><td id="40786019_494"><p>好</p></td><td id="40786019_495"><p>不灵活</p></td><td id="40786019_496"><p>自动检测</p></td><td id="40786019_497"><p>启动慢</p></td></tr><tr id="40786019_498"><td id="40786019_499"><p>Setter Injection</p></td><td id="40786019_500"><p>不可靠</p></td><td id="40786019_501"><p>差</p></td><td id="40786019_502"><p>好</p></td><td id="40786019_503"><p>灵活</p></td><td id="40786019_504"><p>不检测</p></td><td id="40786019_505"><p>启动快</p></td></tr></tbody ></table ></div><aside class="prompt" data-type="tip" data-title="" id="40786019_506"><ol class="list _decimal" id="40786019_507"  type="1"  ><li class="list__item" id="40786019_508"><p>可靠性 </p><ol class="list _decimal" id="40786019_509"  type="1"  ><li class="list__item" id="40786019_510"><p>对象构建和使用过程，看对象在各阶段的使用是否可靠</p></li><li class="list__item" id="40786019_511"><p>构造函数有严格的构建顺序和不可变性，一旦构建就可用，且不会被更改</p></li></ol></li><li class="list__item" id="40786019_512"><p>可维护性 </p><ol class="list _decimal" id="40786019_513"  type="1"  ><li class="list__item" id="40786019_514"><p>更容易阅读，分析依赖关系</p></li><li class="list__item" id="40786019_515"><p>构造函数中可以明显分析出依赖关系</p></li></ol></li><li class="list__item" id="40786019_516"><p>可测试性 </p><ol class="list _decimal" id="40786019_517"  type="1"  ><li class="list__item" id="40786019_518"><p>在复杂的依赖关系下，更容易的编写单元测试来评判</p></li><li class="list__item" id="40786019_519"><p>Constructor Injection和 Setter Injection的方式更容易Mock和注入对象，更容易实现单元测试</p></li></ol></li><li class="list__item" id="40786019_520"><p>灵活性 </p><ol class="list _decimal" id="40786019_521"  type="1"  ><li class="list__item" id="40786019_522"><p>开发实现时候的编码灵活</p></li><li class="list__item" id="40786019_523"><p>Constructor Injection对Bean依赖关系有着严格的顺序要求</p></li></ol></li><li class="list__item" id="40786019_524"><p>性能影响 </p><ol class="list _decimal" id="40786019_525"  type="1"  ><li class="list__item" id="40786019_526"><p>Constructor Injection 严格的顺序要求，会拉长启动时间</p></li></ol></li></ol></aside></section></section></section><section class="chapter"><h3 id="resource" data-toc="resource">Resource</h3><aside class="prompt" data-type="tip" data-title="" id="40786019_527"><p id="40786019_528">javax.annotation.Resource</p></aside><section class="chapter"><h4 id="autowire" data-toc="autowire">和Autowire区别</h4><aside class="prompt" data-type="tip" data-title="" id="40786019_529"><ul class="list _ul" id="40786019_530"    ><li class="list__item" id="40786019_531"><p>Autowire </p><ul class="list _ul" id="40786019_532"    ><li class="list__item" id="40786019_533"><p>默认通过类型注入，如果存在多个类型则通过名称注入</p></li><li class="list__item" id="40786019_534"><p>可以使用@Primary定义类名，优先使用</p></li><li class="list__item" id="40786019_535"><p>使用@Qualifier(&quot;xxx&quot;)，指定类名注入 （合格者）</p></li></ul></li><li class="list__item" id="40786019_536"><p>Resource </p><ul class="list _ul" id="40786019_537"    ><li class="list__item" id="40786019_538"><p>默认使用名称注入，如果名称找不到，则通过类型注入</p></li></ul></li><li class="list__item" id="40786019_539"><p>bean默认是开头字母小写的类名</p></li></ul></aside></section></section><section class="chapter"><h3 id="transactional" data-toc="transactional">Transactional</h3><ul class="list _ul" id="40786019_540"    ><li class="list__item" id="40786019_541"><p>回滚rollbackFor()。默认是RuntimeException </p><ul class="list _ul" id="40786019_542"    ><li class="list__item" id="40786019_543"><p>IOException不是RuntimeException子类，不会进行事务回滚</p></li></ul></li></ul><div class="code-block" data-lang="java"         >
@Transactional(rollbackFor = IOException.class)
public class Clazz {
    
}
</div></section><section class="chapter"><h3 id="requestparam-requestbody" data-toc="requestparam-requestbody">RequestParam &amp; RequestBody</h3><section class="chapter"><h4 id="requestparam" data-toc="requestparam">RequestParam</h4><aside class="prompt" data-type="tip" data-title="" id="40786019_545"><p id="40786019_546">接收的参数是来自HTTP请求体或</p></aside></section><section class="chapter"><h4 id="requestbody" data-toc="requestbody">RequestBody</h4></section></section><section class="chapter"><h3 id="javaconfig" data-toc="javaconfig">JavaConfig</h3><p id="40786019_547">注解的方式开发，代替xml</p><ol class="list _decimal" id="40786019_548"  type="1"  ><li class="list__item" id="40786019_549"><p>@Configuration</p></li><li class="list__item" id="40786019_550"><p>@Bean</p></li><li class="list__item" id="40786019_551"><p>@ComponentScan</p></li><li class="list__item" id="40786019_552"><p>@EnableWebMvc</p></li><li class="list__item" id="40786019_553"><p>@ImportResource</p></li><li class="list__item" id="40786019_554"><p>@PropertySource</p></li></ol></section></section><section class="chapter"><h2 id="40786019_555" data-toc="40786019_555">依赖</h2><section class="chapter"><h3 id="spring-boot-starter-parent" data-toc="spring-boot-starter-parent">spring-boot-starter-parent</h3><ol class="list _decimal" id="40786019_556"  type="1"  ><li class="list__item" id="40786019_557"><p id="40786019_558">Java版本</p><div class="code-block" data-lang="markup"         >
&lt;properties&gt;
   &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
</div></li><li class="list__item" id="40786019_560"><p id="40786019_561">源码文件编码</p><div class="code-block" data-lang="markup"         >
&lt;properties&gt;
  &lt;project.build.sourceEncoding&gt;GBK&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;
</div></li><li class="list__item" id="40786019_563"><p id="40786019_564">依赖管理</p></li><li class="list__item" id="40786019_565"><p id="40786019_566">打包支持</p></li><li class="list__item" id="40786019_567"><p id="40786019_568">动态识别资源</p><div class="code-block" data-lang="markup"         >
&lt;resource&gt;
  &lt;directory&gt;src/main/resources&lt;/directory&gt;
  &lt;includes&gt;
    &lt;include&gt;**/*.*&lt;/include&gt;
  &lt;/includes&gt;
  &lt;filtering&gt;true&lt;/filtering&gt;
&lt;/resource&gt;
</div></li><li class="list__item" id="40786019_570"><p id="40786019_571">识别插件设置。如exec plugin,surefire,Git commit ID等</p></li><li class="list__item" id="40786019_572"><p id="40786019_573">设别不同的配置。如application-dev.properties和 application-dev.yml</p></li></ol><p id="40786019_574">有些继承自其父级spring-boot-dependencies</p></section></section><section class="chapter"><h2 id="40786019_575" data-toc="40786019_575">事务</h2><aside class="prompt" data-type="tip" data-title="" id="40786019_576"><p id="40786019_577">Spring采用ThreadLocal方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时采用这种方式可以使业务层使用数据库时不需要感知并管理connection对象，通过传播级别，巧妙管理多个事务配置间的切换、挂起和恢复。</p></aside><aside class="prompt" data-type="tip" data-title="" id="40786019_578"><p id="40786019_579"><span class="control" id="40786019_580">主要用的就是ThreadLocal和AOP实现， <span class="control" id="40786019_581">每个线程的链接都是靠ThreadLocal保存 底层核心是</span>动态代理</span></p></aside><section class="chapter"><h3 id="40786019_582" data-toc="40786019_582">不生效</h3><ol class="list _decimal" id="40786019_583"  type="1"  ><li class="list__item" id="40786019_584"><p id="40786019_585">Bean没有纳入Spring容器管理</p><ol class="list _decimal" id="40786019_586"  type="1"  ><li class="list__item" id="40786019_587"><p>（不是动态代理的Bean），里面方法是没有事务管理的</p></li></ol></li><li class="list__item" id="40786019_588"><p id="40786019_589">自调用</p><ol class="list _decimal" id="40786019_590"  type="1"  ><li class="list__item" id="40786019_591"><p id="40786019_592">调用当前类的方法，比如用this调用当前类的的方法</p></li><li class="list__item" id="40786019_593"><p id="40786019_594">原因：this.methodA()，没有走TestService的代理类，所以事务会失效</p></li><li class="list__item" id="40786019_595"><p id="40786019_596">解决</p><ol class="list _decimal" id="40786019_597"  type="1"  ><li class="list__item" id="40786019_598"><p id="40786019_599">methodA()和methodB()分别放到不同的类中</p></li><li class="list__item" id="40786019_600"><p id="40786019_601">自己注入自己，用注入的实例调用</p></li><li class="list__item" id="40786019_602"><p id="40786019_603">获取动态代理类，调用自己类的方法 且设置暴露当前代理对象到本地线程(<code class="code" id="40786019_604">@EnableAspectJAutoProxy(expostProxy=true)</code>)</p><div class="code-block" data-lang="java"         >
@Service
public class TestService{ 

    @Transactional
    public void methodA(){

    }
    public void methodB() {
      ((TestService)AopContext.currentProxy()).methodA();
    }
} 
</div></li></ol></li></ol></li><li class="list__item" id="40786019_606"><p id="40786019_607">异常没有抛出了，被try catch了</p></li><li class="list__item" id="40786019_608"><p id="40786019_609">抛出的不是RuntimeException，而且没有指定rollbackFor=异常类型</p></li><li class="list__item" id="40786019_610"><p id="40786019_611">事务方法不是public的，不会被动态代理</p></li><li class="list__item" id="40786019_612"><p id="40786019_613">事务方法内启用新线程进行异步操作</p></li><li class="list__item" id="40786019_614"><p id="40786019_615">数据库不支持事务</p></li></ol></section><section class="chapter"><h3 id="40786019_616" data-toc="40786019_616">五种事务隔离级别</h3><div class="table-wrapper" ><table class="wide" id="40786019_617"  ><thead><tr class="ijRowHead" id="40786019_618"><th id="40786019_619"><p>隔离级别</p></th><th id="40786019_620"><p>说明</p></th></tr></thead><tbody ><tr id="40786019_621"><td id="40786019_622"><p><span class="control" id="40786019_623">DEFAULT</span></p></td><td id="40786019_624"><p>使用数据库默认的事务隔离级别</p></td></tr><tr id="40786019_625"><td id="40786019_626"><p><span class="control" id="40786019_627">READ_COMMITTED</span></p></td><td id="40786019_628"><p>读已提交：防止脏读。但会出现不可重复读和幻读</p></td></tr><tr id="40786019_629"><td id="40786019_630"><p><span class="control" id="40786019_631">READ_UNCOMMITTED</span></p></td><td id="40786019_632"><p>读未提交：最低隔离级别事务。会产生脏读、不可重复读和幻读</p></td></tr><tr id="40786019_633"><td id="40786019_634"><p><span class="control" id="40786019_635">REPEATABLE_READ</span></p></td><td id="40786019_636"><p>可重复读：可以防止脏读、不可重复读。但会幻读</p></td></tr><tr id="40786019_637"><td id="40786019_638"><p><span class="control" id="40786019_639">SERIALIZABLE</span></p></td><td id="40786019_640"><p>串行化：最高隔离级别最可靠</p></td></tr></tbody ></table ></div></section><section class="chapter"><h3 id="40786019_641" data-toc="40786019_641">七种事务传播行为</h3><div class="table-wrapper" ><table class="wide" id="40786019_642"  ><thead><tr class="ijRowHead" id="40786019_643"><th id="40786019_644"><p>传播行为</p></th><th id="40786019_645"><p>说明</p></th></tr></thead><tbody ><tr id="40786019_646"><td id="40786019_647"><p><span class="control" id="40786019_648">REQUIRED</span></p></td><td id="40786019_649"><p>若存在事务，则支持当前事务，否则开启一个新的事务</p></td></tr><tr id="40786019_650"><td id="40786019_651"><p><span class="control" id="40786019_652">SUPPORTS</span></p></td><td id="40786019_653"></td></tr><tr id="40786019_654"><td id="40786019_655"><p><span class="control" id="40786019_656">MANDATORY</span></p></td><td id="40786019_657"></td></tr><tr id="40786019_658"><td id="40786019_659"><p><span class="control" id="40786019_660">REQUIRES_NEW</span></p></td><td id="40786019_661"><p>总是新开，挂起当前事务</p></td></tr><tr id="40786019_662"><td id="40786019_663"><p><span class="control" id="40786019_664">NOT_SUPPORTED</span></p></td><td id="40786019_665"></td></tr><tr id="40786019_666"><td id="40786019_667"><p><span class="control" id="40786019_668">NEVER</span></p></td><td id="40786019_669"></td></tr><tr id="40786019_670"><td id="40786019_671"><p><span class="control" id="40786019_672">NESTED</span></p></td><td id="40786019_673"></td></tr></tbody ></table ></div></section></section><section class="chapter"><h2 id="other" data-toc="other">Other</h2><section class="chapter"><h3 id="springboot" data-toc="springboot">SpringBoot属性加载顺序</h3><aside class="prompt" data-type="tip" data-title="" id="40786019_675"><p id="40786019_676">加载顺序是从高到低</p></aside><ol class="list _decimal" id="40786019_677"  type="1"  ><li class="list__item" id="40786019_678"><p>命令行参数，ex: java -jar -Dspring.profile.active</p></li><li class="list__item" id="40786019_679"><p>操作系统环境变量</p></li><li class="list__item" id="40786019_680"><p>application.properties或application.yml</p></li><li class="list__item" id="40786019_681"><p>@Configuration注解的类，@PropertySource注解的属性</p></li></ol></section></section><div class="last-modified"> Last modified: 28 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="javafxpackage.html">JavaFx打包</a>   <a class="navigation-links__next" href="redis.html">Redis</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>