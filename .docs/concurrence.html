<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2023-11-28T23:26:37.6596098"><meta name="build-number" content="${buildNumber}">       <title>并发 | Yui</title><script id="virtual-toc-data" type="application/json">[{"id":"java-util-concurrent","level":0,"title":"java.util.concurrent","anchor":"#java-util-concurrent"},{"id":"9483967d_80","level":0,"title":"锁","anchor":"#9483967d_80"},{"id":"java-lang","level":0,"title":"java.lang","anchor":"#java-lang"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="并发 | Yui"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Yui Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="concurrence.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="并发 | Yui"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "concurrence.html#webpage", "url": "concurrence.html", "name": "并发 | Yui", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Yui Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Concurrence" data-main-title="并发" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="java"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Yui  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Concurrence"  id="Concurrence.md"  >并发</h1>  <section class="chapter"><h2 id="java-util-concurrent" data-toc="java-util-concurrent">java.util.concurrent</h2><section class="chapter"><h3 id="semaphore" data-toc="semaphore">信号量 Semaphore</h3><section class="chapter"><h4 id="9483967d_71" data-toc="9483967d_71">一、概念</h4><p id="9483967d_72">控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源</p></section><section class="chapter"><h4 id="9483967d_73" data-toc="9483967d_73">二、使用场景</h4><p id="9483967d_74">资源有明确访问数量限制的场景，常用于限流</p><aside class="prompt" data-type="tip" data-title="" id="9483967d_75"><p id="9483967d_76">如数据库连接池、停车场场景。满了需要线程</p></aside></section><section class="chapter"><h4 id="9483967d_77" data-toc="9483967d_77">三、常用方法</h4><aside class="prompt" data-type="tip" data-title="" id="9483967d_78"><p id="9483967d_79">acquire()</p></aside></section></section></section><section class="chapter"><h2 id="9483967d_80" data-toc="9483967d_80">锁</h2><section class="chapter"><h3 id="synchronized" data-toc="synchronized">Synchronized</h3><section class="chapter"><h4 id="9483967d_81" data-toc="9483967d_81">锁分类</h4><ol class="list _decimal" id="9483967d_82"  type="1"  ><li class="list__item" id="9483967d_83"><p>重量级锁：jdk1.6之前仅有重量级锁</p></li><li class="list__item" id="9483967d_84"><p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p></li><li class="list__item" id="9483967d_85"><p>使用 </p><ol class="list _decimal" id="9483967d_86"  type="1"  ><li class="list__item" id="9483967d_87"><p>偏向锁 </p><ol class="list _decimal" id="9483967d_88"  type="1"  ><li class="list__item" id="9483967d_89"><p>每次只有一个线程去拿锁，且是同一个线程，相当于单线程环境，可以使用偏向锁</p></li><li class="list__item" id="9483967d_90"><p>没有线程的竞争</p></li><li class="list__item" id="9483967d_91"><p>第一次会标记，之后只进行比较线程即可</p></li></ol></li><li class="list__item" id="9483967d_92"><p>轻量级锁 </p><ol class="list _decimal" id="9483967d_93"  type="1"  ><li class="list__item" id="9483967d_94"><p>有锁的竞争，但竞争不是很激烈</p></li><li class="list__item" id="9483967d_95"><p>多个线程交替执行</p></li><li class="list__item" id="9483967d_96"><p>使用CAS，自旋来获取锁</p></li></ol></li><li class="list__item" id="9483967d_97"><p>重量级锁 </p><ol class="list _decimal" id="9483967d_98"  type="1"  ><li class="list__item" id="9483967d_99"><p>线程竞争激烈，多个线程都要去获取锁</p></li><li class="list__item" id="9483967d_100"><p>操作系统底层对锁的互斥</p></li><li class="list__item" id="9483967d_101"><p>性能差一些</p></li></ol></li></ol></li></ol><div class="code-block" data-lang="java"         >
public class Test {

    public static void main(String[] args) {
        //Main main = new Main();
        new Thread(()-&gt;{
            Main main = new Main();
            main.get();
        }).start();
        new Thread(()-&gt;{
            Main main = new Main();
            main.get();
        }).start();
    }

}

class Main{
    private static int i = 0;

    public synchronized void get(){
        i++;
        System.out.println(i);
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="9483967d_103"><ol class="list _decimal" id="9483967d_104"  type="1"  ><li class="list__item" id="9483967d_105"><p>get方法上加锁，锁住的是对象。因为get方法不是static</p></li><li class="list__item" id="9483967d_106"><p>两个线程如果同时使用同一个Main对象，第一个线程会先拿到锁，所以会输出1,2不变</p></li><li class="list__item" id="9483967d_107"><p>两个线程如果使用不同的Main对象，因为是实例锁，两个线程不会互斥。 </p><ol class="list _decimal" id="9483967d_108"  type="1"  ><li class="list__item" id="9483967d_109"><p>如果i不是static，那么输出都会是1</p></li><li class="list__item" id="9483967d_110"><p>i是static，两个线程并发时，都可能会先执行i++，和输出i，所以存在1,2、2,2、 <span class="control" id="9483967d_111">2,1</span>三种情况 </p><ol class="list _decimal" id="9483967d_112"  type="1"  ><li class="list__item" id="9483967d_113"><p>Main.i是共享可变,两个线程使用lock是不一样的，线程1先执行i++，线程2看到线程1所做的改变，i++和输出2，线程1没看到线程2所做的改变，看到i还是i，输出1</p></li></ol></li></ol></li><li class="list__item" id="9483967d_114"><p>原子性和可见性问题</p></li></ol></aside></section></section></section><section class="chapter"><h2 id="java-lang" data-toc="java-lang">java.lang</h2><section class="chapter"><h3 id="threadlocal" data-toc="threadlocal">ThreadLocal</h3><aside class="prompt" data-type="tip" data-title="" id="9483967d_115"><p id="9483967d_116">线程池对线程的复用会影响后续业务逻辑和造成内存泄漏，会复用ThreadLocal</p></aside><figure  id="9483967d_117"><img alt="image" title="image" src="images/ThreadLocalMap.png"  class="" width="1152" height="327"/></figure><figure  id="9483967d_118"><img alt="image" title="image" src="images/ThreadLocalMap_add.png"  class="" width="640" height="356"/></figure><aside class="prompt" data-type="tip" data-title="" id="9483967d_119"><ol class="list _decimal" id="9483967d_120"  type="1"  ><li class="list__item" id="9483967d_121"><p>栈内存属于单个线程，每个线程都会有个栈内存，其存储变量只能其所属的线程中可见，也可以理解成线程的私有内存。</p></li><li class="list__item" id="9483967d_122"><p>堆内存的对象可以被所有线程访问</p></li><li class="list__item" id="9483967d_123"><p>ThreadLocal实例和值存在堆上，线程可见</p></li><li class="list__item" id="9483967d_124"><p>共享线程的ThreadLocal数据 </p><ol class="list _decimal" id="9483967d_125"  type="1"  ><li class="list__item" id="9483967d_126"><p>主线程创建InheritableThreadLocal()实例</p></li><li class="list__item" id="9483967d_127"><p>子线程通过这个实例可以获得值</p></li></ol></li><li class="list__item" id="9483967d_128"><p>ThreadLocal问题 </p><ol class="list _decimal" id="9483967d_129"  type="1"  ><li class="list__item" id="9483967d_130"><p>key被设计成弱引用WeakReference。key被gc了，但value还在。</p></li><li class="list__item" id="9483967d_131"><p>内存泄漏 </p><ol class="list _decimal" id="9483967d_132"  type="1"  ><li class="list__item" id="9483967d_133"><p>线程池的线程复用，之前线程实例处理完之后，出于复用目的线程依然存活，ThreadLocal的value值被持有，导致内存泄漏</p></li><li class="list__item" id="9483967d_134"><p>解决：使用完，调用remove()，值清空</p></li></ol></li><li class="list__item" id="9483967d_135"><p>为什么key弱引用 </p><ol class="list _decimal" id="9483967d_136"  type="1"  ><li class="list__item" id="9483967d_137"><p>会造成和entry中value一样的内存泄漏</p></li></ol></li></ol></li></ol></aside></section></section><div class="last-modified"> Last modified: 28 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="jvm.html">JVM</a>   <a class="navigation-links__next" href="basics.html">基础</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>