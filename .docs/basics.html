<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2023-11-28T23:26:37.7496917"><meta name="build-number" content="${buildNumber}">       <title>基础 | Yui</title><script id="virtual-toc-data" type="application/json">[{"id":"b086f20_173","level":0,"title":"内部类","anchor":"#b086f20_173"},{"id":"b086f20_200","level":0,"title":"抽象类 \u0026 接口","anchor":"#b086f20_200"},{"id":"b086f20_256","level":0,"title":"关键字","anchor":"#b086f20_256"},{"id":"b086f20_297","level":0,"title":"设计模式","anchor":"#b086f20_297"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="基础 | Yui"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Yui Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="basics.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="基础 | Yui"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "basics.html#webpage", "url": "basics.html", "name": "基础 | Yui", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Yui Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Basics" data-main-title="基础" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="java"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Yui  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Basics"  id="Basics.md"  >基础</h1>  <section class="chapter"><h2 id="b086f20_173" data-toc="b086f20_173">内部类</h2><aside class="prompt" data-type="tip" data-title="" id="b086f20_174"><ul class="list _ul" id="b086f20_175"    ><li class="list__item" id="b086f20_176"><p>成员内部类：作为成员对象的内部类，可以访问private及以上外部类的属性和方法，外部类想要访问内部类属性或方法时，需要创建一个内部类对象，然后通过该对象访问内部类属性或方法。外部类也可以访问private修饰的内部类属性</p></li><li class="list__item" id="b086f20_177"><p>局部内部类：存在方法中的内部类，访问权限类似局部变量，只能访问外部类的final变量</p></li><li class="list__item" id="b086f20_178"><p>匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量</p></li><li class="list__item" id="b086f20_179"><p>静态内部类：类似类的静态成员变量</p></li></ul></aside><figure  id="b086f20_180"><img alt="image-20220405162113568" title="image-20220405162113568" src="images/inner-class.png"  class="" width="513" height="288"/></figure><section class="chapter"><h3 id="b086f20_181" data-toc="b086f20_181">一、成员内部类，也称作普通内部类</h3><div class="code-block" data-lang="java"         >
//外部类Outer
public class Outer {
    private int a = 99; //外部类私有属性
    public class Inner {
        int b = 2 ;
        public void test() {
            System.out.println(&quot;访问外部类中的a：&quot; + a);
            System.out.println(&quot;访问内部类中的b：&quot; + );
        }
    }
    //测试成员内部类
    public static void main (String[] args) {
        Outer o = new  Outer(); //创建外部类对象
        Inner i = o.new Inner(); //使用外部类对象创建内部类对象
        i.test(); //调用内部类对象的test方法
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="b086f20_183"><ol class="list _decimal" id="b086f20_184"  type="1"  ><li class="list__item" id="b086f20_185"><p>内部类相当于外部类成员变量的位置，可以使用任意访问修饰符，public、private、protected、default</p></li><li class="list__item" id="b086f20_186"><p>内部类的方法可以访问外部类的变量，不受访问控制符限制</p></li><li class="list__item" id="b086f20_187"><p>实例化对象：new Outer().new Inner().test()</p></li><li class="list__item" id="b086f20_188"><p>相同变量名，内部类的可以直接访问，访问外部类的需要使用this关键字</p></li></ol></aside></section><section class="chapter"><h3 id="b086f20_189" data-toc="b086f20_189">二、静态内部类</h3><div class="code-block" data-lang="java"         >
public class HelloWorld{
    String name = &quot;xx&quot;;
    public static class Inner {
        public void show() {
            System.out.println(&quot;访问外部类中的name：&quot; + new HelloWorl().name);
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="b086f20_191"><ol class="list _decimal" id="b086f20_192"  type="1"  ><li class="list__item" id="b086f20_193"><p>静态内部类不能直接访问外部类的非静态成员，需要实例化外部类再访问</p></li><li class="list__item" id="b086f20_194"><p>创建对象时，不需要使用外部来对象，可以直接创建</p></li><li class="list__item" id="b086f20_195"><p>相同变量名：外部类的需要使用 &quot;类名.静态成员&quot;</p></li></ol></aside></section><section class="chapter"><h3 id="b086f20_196" data-toc="b086f20_196">三、方法内部类</h3><div class="code-block" data-lang="java"         >
public class MOuter {
    public void show() {
        final int a = 25;
        int b = 13;
        class MInner {
            int c = 2;
            public void print() {
                System.out.println(&quot;访问外部类方法中的常量a：&quot; + a);
                System.out.println(&quot;访问内部类的变量c：&quot; + c);
            }
        }
        MInner mi = new MInner();
        mi.print();
    }
    
    public static void main(String[] args ) {
        MOuter mo = new Mouter();
        mo.show();
    } 
}
</div><aside class="prompt" data-type="tip" data-title="" id="b086f20_198"><p id="b086f20_199">方法内部类无法在外部类的方法外的地方使用，因此方法内部类不能使用访问控制符和static 修饰符</p></aside></section></section><section class="chapter"><h2 id="b086f20_200" data-toc="b086f20_200">抽象类 &amp; 接口</h2><ol class="list _decimal" id="b086f20_201"  type="1"  ><li class="list__item" id="b086f20_202"><p>都是将方法抽象，让子类去实现。</p></li><li class="list__item" id="b086f20_203"><p>抽象类进一步抽象后，就诞生了接口</p></li><li class="list__item" id="b086f20_204"><p><span class="control" id="b086f20_205">接口是更纯粹的抽象类</span> ，没有成员属性和构造器，只留下了静态常量和方法，更能体现<span class="control" id="b086f20_206">标准和规范</span>的含义</p></li></ol><section class="chapter"><h3 id="b086f20_207" data-toc="b086f20_207">异同</h3><div class="table-wrapper" ><table class="wide" id="b086f20_208"  ><thead><tr class="ijRowHead" id="b086f20_209"><th id="b086f20_210"></th><th id="b086f20_211"><p>抽象类（abstract class）</p></th><th id="b086f20_212"><p>接口（interface）</p></th></tr></thead><tbody ><tr id="b086f20_213"><td id="b086f20_214"><p>定义</p></td><td id="b086f20_215"><p>包含抽象方法的类</p></td><td id="b086f20_216"><p>主要是抽象方法和静态常量的类</p></td></tr><tr id="b086f20_217"><td id="b086f20_218"><p>组成</p></td><td id="b086f20_219"><p>构造器</p><br><p> 抽象方法</p><br><p> 普通成员方法、成员变量</p><br><p> 静态方法、静态变量</p><br><p> 常量</p></td><td id="b086f20_224"><p>静态常量</p><br><p> 抽象方法</p><br><p> default方法、静态方法（Java 8） </p><br><p> 私有方法（Java 9）</p></td></tr><tr id="b086f20_228"><td id="b086f20_229"><p>使用</p></td><td id="b086f20_230"><p>子类继承抽象类（extends）</p></td><td id="b086f20_231"><p>子类实现接口（implements）</p></td></tr><tr id="b086f20_232"><td id="b086f20_233"><p>关系</p></td><td id="b086f20_234"><p>子类只能继承一个抽象类</p><br><p> 抽象类可以实现多个接口</p></td><td id="b086f20_236"><p>子类可以实现多个接口</p><br><p> 接口不能继承类，但可以继承多个接口</p></td></tr><tr id="b086f20_238"><td id="b086f20_239"><p>选择</p></td><td id="b086f20_240"><p>如果需要继承父类的成员变量，或者需要控制子类的实例化，则选择抽象类</p></td><td id="b086f20_241"><p>优先选择接口，避免单继承的局限</p></td></tr></tbody ></table ></div><aside class="prompt" data-type="tip" data-title="" id="b086f20_242"><ol class="list _decimal" id="b086f20_243"  type="1"  ><li class="list__item" id="b086f20_244"><p>接口可以静态方法以及<code class="code" id="b086f20_245">default</code>关键字来实现方法，就不再是抽象方法了，不会强制要求已有的子类去实现</p></li><li class="list__item" id="b086f20_246"><p><code class="code" id="b086f20_247">java 8</code> 有许多原有的接口，新增了很多方法，会影响到继承的子类，如果没有实现，子类就会编译报错， <span class="control" id="b086f20_248">向下兼容</span></p></li><li class="list__item" id="b086f20_249"><p>由于大量在接口中定义默认方法，但在方法中使用复杂逻辑，会导致代码难以维护， <code class="code" id="b086f20_250">java 9</code> 中定义 <code class="code" id="b086f20_251">private</code>方法，内部逻辑就拆开了</p></li><li class="list__item" id="b086f20_252"><p>抽象类和接口的差异越来越小</p></li></ol></aside><aside class="prompt" data-type="tip" data-title="" id="b086f20_253"><p id="b086f20_254">例如：List接口新增了sort方法</p></aside><div class="code-block" data-lang="java"         >
public interface List&lt;E&gt; extends Collection&lt;E&gt; {
    //...其他成员
    default void sort(Comparator&lt;? super E&gt; c) {
        //logic code
    }
}
</div></section></section><section class="chapter"><h2 id="b086f20_256" data-toc="b086f20_256">关键字</h2><section class="chapter"><h3 id="static" data-toc="static">static</h3><section class="chapter"><h4 id="b086f20_257" data-toc="b086f20_257">用途</h4><ul class="list _ul" id="b086f20_258"    ><li class="list__item" id="b086f20_259"><p>静态属性</p></li><li class="list__item" id="b086f20_260"><p>静态方法</p></li><li class="list__item" id="b086f20_261"><p>静态代码块</p></li><li class="list__item" id="b086f20_262"><p>静态导包</p></li></ul></section><section class="chapter"><h4 id="b086f20_263" data-toc="b086f20_263">使用</h4><ol class="list _decimal" id="b086f20_264"  type="1"  ><li class="list__item" id="b086f20_265"><p>不用创建对象，直接通过类名就可以调用静态属性和静态方法</p></li><li class="list__item" id="b086f20_266"><p>与之对应的成员属性和成员方法。 </p><ol class="list _decimal" id="b086f20_267"  type="1"  ><li class="list__item" id="b086f20_268"><p><span class="control" id="b086f20_269">静态的属于类；成员的属于对象</span></p></li><li class="list__item" id="b086f20_270"><p>静态的在没有对象创建时，就已经存在了，所以无法访问成员的</p></li></ol></li></ol><figure  id="b086f20_271"><img alt="image-20220410224722948" title="image-20220410224722948" src="images/static-property.jpg"  class="" width="517" height="193"/></figure></section><section class="chapter"><h4 id="b086f20_272" data-toc="b086f20_272">初始化顺序</h4><ol class="list _decimal" id="b086f20_273"  type="1"  ><li class="list__item" id="b086f20_274"><p><span class="control" id="b086f20_275">类 &gt; 对象</span>； <span class="control" id="b086f20_276">父类 &gt; 子类</span>； <span class="control" id="b086f20_277">静态 &gt; 成员 &gt; 构造器</span></p></li><li class="list__item" id="b086f20_278"><p>父类：静态属性、静态代码块</p></li><li class="list__item" id="b086f20_279"><p>子类：静态属性、静态代码块</p></li><li class="list__item" id="b086f20_280"><p>父类：成员属性、普通代码块</p></li><li class="list__item" id="b086f20_281"><p>父类：构造器</p></li><li class="list__item" id="b086f20_282"><p>子类：成员属性、普通代码块</p></li><li class="list__item" id="b086f20_283"><p>子类：构造器</p></li></ol></section></section><section class="chapter"><h3 id="native" data-toc="native">native</h3><aside class="prompt" data-type="tip" data-title="" id="b086f20_284"><p id="b086f20_285">说明其修饰的方法是一个原生态方法，方法对应的实现不在当前文件，而是在用其他的语言（如c或c++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但可以通过JNI接口调用其他语言调用其他语言来实现对底层的访问</p></aside><aside class="prompt" data-type="tip" data-title="" id="b086f20_286"><p id="b086f20_287"><span class="control" id="b086f20_288">JNI</span>是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。</p></aside><section class="chapter"><h4 id="native" data-toc="native">native 用法</h4><ol class="list _decimal" id="b086f20_289"  type="1"  ><li class="list__item" id="b086f20_290"><p>编写带native声明的方法的Java类（java文件）</p></li><li class="list__item" id="b086f20_291"><p>使用javac命令编译编写Java类（class文件）</p></li><li class="list__item" id="b086f20_292"><p>使用<span class="control" id="b086f20_293">javah -jni xxx</span> 来生成或后缀名为.h的头文件（.h文件）</p></li><li class="list__item" id="b086f20_294"><p>使用其他语言（C、C++）实现本地方法</p></li><li class="list__item" id="b086f20_295"><p>将本地方法编写的文件生成动态链接库（dll文件）</p></li></ol></section></section><section class="chapter"><h3 id="clone" data-toc="clone">clone</h3><figure  id="b086f20_296"><img alt="image-20220416134826842" title="image-20220416134826842" src="images/image-20220416134826842.png"  class="" width="525" height="269"/></figure></section></section><section class="chapter"><h2 id="b086f20_297" data-toc="b086f20_297">设计模式</h2><section class="chapter"><h3 id="b086f20_298" data-toc="b086f20_298">单例模式</h3><section class="chapter"><h4 id="b086f20_299" data-toc="b086f20_299">要素</h4><ul class="list _ul" id="b086f20_300"    ><li class="list__item" id="b086f20_301"><p>私有的构造方法</p></li><li class="list__item" id="b086f20_302"><p>指向自己实例的私有静态引用</p></li><li class="list__item" id="b086f20_303"><p>以自己实例为返回值的静态公有方法</p></li></ul></section><section class="chapter"><h4 id="b086f20_304" data-toc="b086f20_304">经典实现</h4><ul class="list _ul" id="b086f20_305"    ><li class="list__item" id="b086f20_306"><p>一、饿汉式单例（立即加载）</p></li><li class="list__item" id="b086f20_307"><p>二、懒汉式单例（延迟加载） </p><ul class="list _ul" id="b086f20_308"    ><li class="list__item" id="b086f20_309"><p>传统的懒汉式单例</p></li><li class="list__item" id="b086f20_310"><p>synchronized方法</p></li><li class="list__item" id="b086f20_311"><p>synchronized块</p></li><li class="list__item" id="b086f20_312"><p>volatile关键字修饰单例引用</p></li><li class="list__item" id="b086f20_313"><p>内部类实现延迟加载</p></li><li class="list__item" id="b086f20_314"><p>借助 ThreadLocal</p></li></ul></li></ul><section class="chapter"><h5 id="b086f20_315" data-toc="b086f20_315">对比</h5><ol class="list _decimal" id="b086f20_316"  type="1"  ><li class="list__item" id="b086f20_317"><p>速度和反应时间来说，饿汉较好</p></li><li class="list__item" id="b086f20_318"><p>资源利用率来说，懒汉较好</p></li></ol></section></section><section class="chapter"><h4 id="b086f20_319" data-toc="b086f20_319">优点</h4><ul class="list _ul" id="b086f20_320"    ><li class="list__item" id="b086f20_321"><p>内存中只有一个对象，节省内存空间</p></li><li class="list__item" id="b086f20_322"><p>避免频繁的创建销毁对象，提高性能</p></li><li class="list__item" id="b086f20_323"><p>避免对共享资源的多重占用，简化访问</p></li><li class="list__item" id="b086f20_324"><p>为整个系统提供一个全局范围点</p></li></ul></section><section class="chapter"><h4 id="b086f20_325" data-toc="b086f20_325">适用场景</h4><ul class="list _ul" id="b086f20_326"    ><li class="list__item" id="b086f20_327"><p>有状态的工具类对象</p></li><li class="list__item" id="b086f20_328"><p>频繁访问数据库或文件的对象</p></li></ul></section><section class="chapter"><h4 id="b086f20_329" data-toc="b086f20_329">线程安全</h4><ul class="list _ul" id="b086f20_330"    ><li class="list__item" id="b086f20_331"><p>饿汉单例线程安全</p></li><li class="list__item" id="b086f20_332"><p>使用synchronized方法实现懒汉式单例；</p></li><li class="list__item" id="b086f20_333"><p>使用synchronized块实现懒汉式单例；</p></li><li class="list__item" id="b086f20_334"><p>使用静态内部类实现懒汉式单例；</p></li><li class="list__item" id="b086f20_335"><p>使用双重检查模式实现懒汉式单例；</p></li><li class="list__item" id="b086f20_336"><p>使用ThreadLocal实现懒汉式单例；</p></li></ul></section><section class="chapter"><h4 id="b086f20_337" data-toc="b086f20_337">总结</h4><p id="b086f20_338">要实现效率高的线程安全单例</p><ul class="list _ul" id="b086f20_339"    ><li class="list__item" id="b086f20_340"><p>尽量减少同步块作用域</p></li><li class="list__item" id="b086f20_341"><p>尽量使用细粒度锁</p></li></ul></section></section></section><div class="last-modified"> Last modified: 28 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="concurrence.html">并发</a>   <a class="navigation-links__next" href="https.html">HTTPS</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>