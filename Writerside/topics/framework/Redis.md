# Redis

## 底层
1. 使用IO多路复用
2. 非CPU密集型任务
3. 纯内存操作
4. 巧妙数据结构

> **非关系型数据，存储在内存中**
>
> 底层是一个大Map，key是字符串，value可能是字符串，哈希，列表等。
> C语言实现，结构体redisObject

## 问答

### 一、单线程原理

> Redis单线程指的是网络请求模块使用了一个线程，其他的模块仍是用了多个线程，并不是一味的单线程完成任务。
>
> 利用了epoll的多路复用特性，因此可以采用单线程来处理网络请求

### 二、Redis数据类型

| 类型   | 描述                                                         | 实现原理                                |
| ------ | ------------------------------------------------------------ | --------------------------------------- |
| String | 字符串类型，最简单的类型                                     | 类似数组的形式存储                      |
| Hash   | 类似Map的一种结构                                            | 采用hashtable或者ziplist进行具体实现    |
| List   | 有序列表                                                     | 采用intset或者hashtable存储             |
| Set    | 无序集合，成员唯一                                           | 采用ziplist或者skiplist + hashtable实现 |
| ZSet   | 带权值的无序集合，即每个ZSet元素还带有另外一个数字代表权值，集合通过权值进行排序 |                                         |

### 三、什么情况下使用Redis

1. 针对热点数据进行缓存
2. 对特定限时数据的存放
3. 针对带热点权值数据排序的list
4. 分布式锁

### 四、缓存的一些问题

#### 1）缓存穿透

##### 简述

> 缓存和数据库都没有需要查询的数据，攻击者不断地发送这种请求，使数据库压力过大

##### 解决

1. 对数据库操作访问前进行校验，对不合法数据直接返回。bitmap
2. 对于经常被访问的，并且数据库没有的键，缓存层记录键=null

#### 2）缓存击穿

##### 简述

> 缓存中没有数据，但数据库中有该数据。
>
> 一般是由于特定数据的缓存时间到期。且当并发访问该数据的用户特别多，因此去数据库取数据导致压力过大

##### 解决

1. 设置热点数据永不过期
2. 对并发数据设置并发锁，降低并发性

#### 3）缓存雪崩

##### 简述

> 一大批数据到过期时间，而从缓存中删除，但该批数据量巨大，查询全部数据库，造成数据库压力过大

##### 解决

1. 缓存数据设置随机过期时间，防止同一时间大量数据过期
2. 设置热点数据永不过期
3. 对于集群部署的情况，将热点数据均匀分布到不同的缓存中

### 五、Redis集群部署方式

1. 主从复制
2. 哨兵模式
3. Cluster集群模式

### 六、Redis的备份

#### 1）RDB

1. 生成当前数据的快照，并保存在硬盘中，可以通过手动命令，也可以设置自动触发
2. save命令：手动出发RDB过程的命令。使用之后，服务器阻塞，直到RDB过程完成后终止，该过程占用内存较多
3. bgsave命令：不完全阻塞主线程，该命令fork一个子进程用于执行RDB过程。其具体过程为：
   1. 判断此时又没有子进程用于RDB，有的话直接返回
   2. Redis进行fork子进程过程，此时父进程处于阻塞状态
   3. 子进程创建RDB文件，完成后返回给父进程
4. 自动触发RDB机制
   1. 通过配置文件，设置一定时间后自动执行RDB
   2. 如采用主从复制过程，会自动执行RDB
   3. Redis执行shutdown时，在未开启AOF后会执行RDB

#### 2）AOF

1. AOF通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF
2. 持久化策略
   1. always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上
   2. everysec。每秒将命令写入到磁盘日志上
   3. no。不主动设置，有操作系统决定什么时候写入到磁盘文件上
3. AOF重写
   1. 随着客户端的不断进行操作，AOF文件也越来越大。Redis提供了bgrewriteaof函数，针对目前数据库数据，在不读取原有AOF文件的基础上，重写了一个新的AOF文件，减少了文件大小。（**去除中间过程**）

#### 3）优缺点

1. AOF占用的文件体积比RDB大
2. 一般来说AOF备份对系统的消耗比RDB低。
3. 对于备份时出现系统故障，RDB数据可能全丢，但AOF只会损失一部分
4. RDB恢复速度比AOF低

### 七、淘汰机制

1. noeviction：默认禁止驱逐数据。内存不够使用时，对申请内存的命令报错。
2. volatile-lru：从设置了过期时间的数据集中淘汰最近没使用的数据。
3. volatile-ttl：从设置了过期时间的数据集中淘汰即将要过期的数据。
4. volatile-random：从设置了过期时间的数据中随机淘汰数据。
5. allkeys-lru：淘汰最近没使用的数据。
6. allkeys-random：随机淘汰数据

### 八、过期策略

1. 定期删除：redis默认是每100ms就随机抽取一些设置了过期时间的key，并检查是否过期，如果过期就会删除。因此该删除策略并不会删除所有的过期key
2. 惰性删除：在客户端需要获取某个key时，redis会先对其进行检查，如果key设置了过期时间且已经过期就会删除
3. 实际上，redis结合两种手段，保证删除过期的key

### 九、Redis快的原因

1. Redis是基于内存的数据库，内存数据读取存储效率远大于硬盘型
2. Redis采用多路复用技术通过而epoll的非阻塞IO，提升了效率


## 命令

| 命令   | 说明              | 用法                          |
| ------ | ----------------- | ----------------------------- |
| SETNX  | set if not exists | setnx key [seconds] value     |
| PSETNX | set               | psetnx key milliseconds value |



### [keys](https://redis.io/commands/keys/)
1. keys命令是通过遍历全部db下的key再过滤实现的
2. keys命令没有汇总各节点查询结果的逻辑，不会路由keys命令
3. 设计目的是 调试或者特殊用途的，不适用于生产环境。
4. 可以使用``SCAN`` 或者 ``sets``


## 分布式锁

### 特性

1. 互斥性
2. 高可用性
3. 防止锁超时
4. 独占性

### 实现分布式锁有哪些坑
1. 不是原子操作
2. 没有释放锁
3. 释放了锁，但业务还没有执行完
4. 释放了别人的锁
5. 大量请求竞争锁失败
6. 多节点Redis主从复制问题
7. 高并发下锁的性能问题



## Websites

1. [Redis Launchpad](https://launchpad.redis.com/)
> Redis官方的用户展示厅，展示各种使用 Redis 的网络应用，并有用法和架构的讲解
2. 