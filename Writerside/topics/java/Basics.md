# 基础



## 内部类

> + 成员内部类：作为成员对象的内部类，可以访问private及以上外部类的属性和方法，外部类想要访问内部类属性或方法时，需要创建一个内部类对象，然后通过该对象访问内部类属性或方法。外部类也可以访问private修饰的内部类属性
> + 局部内部类：存在方法中的内部类，访问权限类似局部变量，只能访问外部类的final变量
> + 匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量
> + 静态内部类：类似类的静态成员变量

![image-20220405162113568](inner-class.png)

#### 一、成员内部类，也称作普通内部类

```java
//外部类Outer
public class Outer {
    private int a = 99; //外部类私有属性
    public class Inner {
        int b = 2 ;
        public void test() {
            System.out.println("访问外部类中的a：" + a);
            System.out.println("访问内部类中的b：" + );
        }
    }
    //测试成员内部类
    public static void main (String[] args) {
        Outer o = new  Outer(); //创建外部类对象
        Inner i = o.new Inner(); //使用外部类对象创建内部类对象
        i.test(); //调用内部类对象的test方法
    }
}
```

> 1. 内部类相当于外部类成员变量的位置，可以使用任意访问修饰符，public、private、protected、default
> 2. 内部类的方法可以访问外部类的变量，不受访问控制符限制
> 2. 实例化对象：new Outer().new Inner().test()
> 2. 相同变量名，内部类的可以直接访问，访问外部类的需要使用this关键字

#### 二、静态内部类

```java
public class HelloWorld{
    String name = "xx";
    public static class Inner {
        public void show() {
            System.out.println("访问外部类中的name：" + new HelloWorl().name);
        }
    }
}
```

> 1. 静态内部类不能直接访问外部类的非静态成员，需要实例化外部类再访问
> 2. 创建对象时，不需要使用外部来对象，可以直接创建
> 3. 相同变量名：外部类的需要使用 "类名.静态成员"

#### 三、方法内部类

```java
public class MOuter {
    public void show() {
        final int a = 25;
        int b = 13;
        class MInner {
            int c = 2;
            public void print() {
                System.out.println("访问外部类方法中的常量a：" + a);
                System.out.println("访问内部类的变量c：" + c);
            }
        }
        MInner mi = new MInner();
        mi.print();
    }
    
    public static void main(String[] args ) {
        MOuter mo = new Mouter();
        mo.show();
    } 
}
```

> 方法内部类无法在外部类的方法外的地方使用，因此方法内部类不能使用访问控制符和static 修饰符



## 抽象类 & 接口
1. 都是将方法抽象，让子类去实现。
2. 抽象类进一步抽象后，就诞生了接口
3. **接口是更纯粹的抽象类**，没有成员属性和构造器，只留下了静态常量和方法，更能体现**标准和规范**的含义

### 异同

|      | 抽象类（abstract class）                                     | 接口（interface）                                            |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义 | 包含抽象方法的类                                             | 主要是抽象方法和静态常量的类                                 |
| 组成 | 构造器<br />抽象方法<br />普通成员方法、成员变量<br />静态方法、静态变量<br />常量 | 静态常量<br />抽象方法<br />default方法、静态方法（Java 8）<br />私有方法（Java 9） |
| 使用 | 子类继承抽象类（extends）                                    | 子类实现接口（implements）                                   |
| 关系 | 子类只能继承一个抽象类<br />抽象类可以实现多个接口           | 子类可以实现多个接口<br />接口不能继承类，但可以继承多个接口 |
| 选择 | 如果需要继承父类的成员变量，或者需要控制子类的实例化，则选择抽象类 | 优先选择接口，避免单继承的局限                               |

> 1. 接口可以静态方法以及``default``关键字来实现方法，就不再是抽象方法了，不会强制要求已有的子类去实现
> 2. ``java 8`` 有许多原有的接口，新增了很多方法，会影响到继承的子类，如果没有实现，子类就会编译报错，**向下兼容**
> 3. 由于大量在接口中定义默认方法，但在方法中使用复杂逻辑，会导致代码难以维护，``java 9`` 中定义 ``private ``方法，内部逻辑就拆开了
> 4. 抽象类和接口的差异越来越小

> 例如：List接口新增了sort方法

```java
public interface List<E> extends Collection<E> {
    //...其他成员
    default void sort(Comparator<? super E> c) {
        //logic code
    }
}
```

## 关键字

### static

#### 用途

+ 静态属性
+ 静态方法
+ 静态代码块
+ 静态导包

#### 使用

1. 不用创建对象，直接通过类名就可以调用静态属性和静态方法
2. 与之对应的成员属性和成员方法。
   1. **静态的属于类；成员的属于对象**
   2. 静态的在没有对象创建时，就已经存在了，所以无法访问成员的

![image-20220410224722948](static-property.jpg)

#### 初始化顺序

1. **类 > 对象**；**父类 > 子类**；**静态 > 成员 > 构造器**
2. 父类：静态属性、静态代码块
3. 子类：静态属性、静态代码块
4. 父类：成员属性、普通代码块
5. 父类：构造器
6. 子类：成员属性、普通代码块
7. 子类：构造器 

### native

> 说明其修饰的方法是一个原生态方法，方法对应的实现不在当前文件，而是在用其他的语言（如c或c++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但可以通过JNI接口调用其他语言调用其他语言来实现对底层的访问

> **JNI**是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。

#### native 用法
1. 编写带native声明的方法的Java类（java文件）
2. 使用javac命令编译编写Java类（class文件）
3. 使用**javah -jni xxx** 来生成或后缀名为.h的头文件（.h文件）
4. 使用其他语言（C、C++）实现本地方法
5. 将本地方法编写的文件生成动态链接库（dll文件）

### clone

![image-20220416134826842](image-20220416134826842.png)

## 设计模式

### 单例模式

#### 要素
+ 私有的构造方法
+ 指向自己实例的私有静态引用
+ 以自己实例为返回值的静态公有方法

#### 经典实现 

+ 一、饿汉式单例（立即加载）
+ 二、懒汉式单例（延迟加载）
  + 传统的懒汉式单例
  + synchronized方法
  + synchronized块
  + volatile关键字修饰单例引用
  + 内部类实现延迟加载
  + 借助 ThreadLocal

##### 对比
1. 速度和反应时间来说，饿汉较好
2. 资源利用率来说，懒汉较好

#### 优点
+ 内存中只有一个对象，节省内存空间
+ 避免频繁的创建销毁对象，提高性能
+ 避免对共享资源的多重占用，简化访问
+ 为整个系统提供一个全局范围点
#### 适用场景
+ 有状态的工具类对象
+ 频繁访问数据库或文件的对象
#### 线程安全
+ 饿汉单例线程安全
+ 使用synchronized方法实现懒汉式单例； 
+ 使用synchronized块实现懒汉式单例； 
+ 使用静态内部类实现懒汉式单例； 
+ 使用双重检查模式实现懒汉式单例； 
+ 使用ThreadLocal实现懒汉式单例；

#### 总结
要实现效率高的线程安全单例
+ 尽量减少同步块作用域
+ 尽量使用细粒度锁
